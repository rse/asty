{"version":3,"sources":["node_modules/grunt-browserify/node_modules/browserify/node_modules/browser-pack/_prelude.js","src/asty-dump.js","src/asty-walk.js","src/asty.js","src/asty-base.js","src/asty-version.js","src/asty-merge.js"],"names":["ASTYDump","dump","maxDepth","undefined","Infinity","out","this","walk","node","depth","i","T","keys","Object","A","length","first","forEach","key","value","replace","RegExp","toString","JSON","stringify","L","C","ASTYWalk","cb","when","_walk","parent","call","child","ASTYBase","_interopRequire","require","ASTYMerge","ASTYVersion","ASTYCtx","ASTYNode","mixins","mixin","proto","prototype","slice","method","_this","version","extend","hasOwnProperty","create","type","init","isA","ASTy","Error","O","P","_name","set","Array","add","arguments","pos","args","_arguments","get","attrs","_add","push","arg","del","found","j","splice","childs","major","minor","micro","date","merge","takePos","attrMap","attrSource","attrTarget"],"mappings":"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","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/*\n**  ASTy -- Abstract Syntax Tree (AST) Data Structure\n**  Copyright (c) 2014-2015 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nexport default class ASTYDump {\n    /*  dump the AST recursively  */\n    dump (maxDepth) {\n        if (maxDepth === undefined)\n            maxDepth = Infinity\n        let out = \"\"\n        this.walk((node, depth /*, parent, when */) => {\n            if (depth > maxDepth)\n                return\n            for (let i = 0; i < depth; i++)\n                out += \"    \"\n            out += node.T + \" \"\n            let keys = Object.keys(node.A)\n            if (keys.length > 0) {\n                out += \"(\"\n                let first = true\n                keys.forEach((key) => {\n                    if (!first)\n                        out += \", \"\n                    else\n                        first = false\n                    out += key + \": \"\n                    let value = node.A[key]\n                    switch (typeof value) {\n                        case \"string\":\n                            out += \"\\\"\" + value.replace(/\\n/, \"\\\\n\").replace(/\"/, \"\\\\\\\"\") + \"\\\"\"\n                            break\n                        case \"object\":\n                            if (value instanceof RegExp)\n                                out += \"/\" +\n                                    value.toString()\n                                    .replace(/^\\//, \"\")\n                                    .replace(/\\/$/, \"\")\n                                    .replace(/\\//g, \"\\\\/\") +\n                                \"/\"\n                            else\n                                out += JSON.stringify(value)\n                            break\n                        default:\n                            out += JSON.stringify(value)\n                            break\n                    }\n                })\n                out += \") \"\n            }\n            out += \"[\" + node.L.L + \"/\" + node.L.C + \"]\\n\"\n        }, \"downward\")\n        return out\n    }\n}\n\n","/*\n**  ASTy -- Abstract Syntax Tree (AST) Data Structure\n**  Copyright (c) 2014-2015 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nexport default class ASTYWalk {\n    /*  walk the AST recursively  */\n    walk (cb, when) {\n        if (typeof when === \"undefined\")\n            when = \"downward\"\n        let _walk = (node, depth, parent) => {\n            if (when === \"downward\" || when === \"both\")\n                cb.call(null, node, depth, parent, \"downward\")\n            node.C.forEach((child) => {\n                _walk(child, depth + 1, node)\n            })\n            if (when === \"upward\" || when === \"both\")\n                cb.call(null, node, depth, parent, \"upward\")\n        }\n        _walk(this, 0, null)\n        return this\n    }\n}\n\n","/*\n**  ASTy -- Abstract Syntax Tree (AST) Data Structure\n**  Copyright (c) 2014-2015 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nimport ASTYBase    from \"./asty-base.js\"\nimport ASTYMerge   from \"./asty-merge.js\"\nimport ASTYWalk    from \"./asty-walk.js\"\nimport ASTYDump    from \"./asty-dump.js\"\nimport ASTYVersion from \"./asty-version.js\"\n\nexport default class ASTYCtx {\n    constructor () {\n        this.ASTYNode = () => {}\n        let mixins = [\n            [ ASTYBase,  \"init\", \"type\", \"pos\", \"set\", \"get\", \"attrs\", \"add\", \"del\", \"childs\", \"parent\" ],\n            [ ASTYMerge, \"merge\" ],\n            [ ASTYWalk,  \"walk\" ],\n            [ ASTYDump,  \"dump\" ]\n        ]\n        mixins.forEach((mixin) => {\n            let proto = mixin[0].prototype\n            mixin.slice(1).forEach((method) => {\n                this.ASTYNode.prototype[method] = proto[method]\n            })\n        })\n        return this\n    }\n    version () {\n        return ASTYVersion\n    }\n    extend (mixin) {\n        for (let method in mixin)\n            if (mixin.hasOwnProperty(method))\n                this.ASTYNode.prototype[method] = mixin[method]\n        return this\n    }\n    create (type) {\n        return (new this.ASTYNode()).init(type)\n    }\n    isA (node) {\n        return (\n               typeof node === \"object\"\n            && node instanceof this.ASTYNode\n            && typeof node.ASTy === \"boolean\"\n            && node.ASTy === true\n        )\n    }\n}\n\n","/*\n**  ASTy -- Abstract Syntax Tree (AST) Data Structure\n**  Copyright (c) 2014-2015 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nexport default class ASTYBase {\n    /*  AST node initialization  */\n    init (T, A, C) {\n        if (typeof T === \"undefined\")\n            throw new Error(\"init: invalid argument\")\n        this.ASTy = true\n        this.T = T\n        this.L = { L: 0, C: 0, O: 0 }\n        this.A = {}\n        this.C = []\n        this.P = null\n        if (typeof A === \"object\") {\n            for (let name in A)\n                if (A.hasOwnProperty(name))\n                    this.set(name, A[name])\n        }\n        if (typeof C === \"object\" && C instanceof Array)\n            this.add(C)\n        return this\n    }\n\n    /*  check the type of an AST node  */\n    type (T) {\n        if (arguments.length === 0)\n            return this.T\n        else if (arguments.length === 1) {\n            this.T = T\n            return this\n        }\n        else\n            throw new Error(\"type: invalid number of arguments\")\n    }\n\n    /*  set the parsing position   */\n    pos (L, C, O) {\n        if (arguments.length === 0)\n            return this.L\n        else if (arguments.length <= 3) {\n            this.L.L = L || 0\n            this.L.C = C || 0\n            this.L.O = O || 0\n            return this\n        }\n        else\n            throw new Error(\"pos: invalid number of arguments\")\n    }\n\n    /*  set AST node attributes  */\n    set () {\n        if (arguments.length === 1 && typeof arguments[0] === \"object\") {\n            let args = arguments\n            Object.keys(args[0]).forEach((key) => {\n                this.A[key] = args[0][key]\n            })\n        }\n        else if (arguments.length === 2)\n            this.A[arguments[0]] = arguments[1]\n        else\n            throw new Error(\"set: invalid arguments\")\n        return this\n    }\n\n    /*  get AST node attributes  */\n    get (key) {\n        if (arguments.length !== 1)\n            throw new Error(\"get: invalid number of arguments\")\n        if (typeof key !== \"string\")\n            throw new Error(\"get: invalid argument\")\n        return this.A[key]\n    }\n\n    /*  get names of all AST node attributes  */\n    attrs () {\n        return Object.keys(this.A)\n    }\n\n    /*  add child AST node(s)  */\n    add () {\n        if (arguments.length === 0)\n            throw new Error(\"add: missing argument(s)\")\n        let _add = (node, child) => {\n            if (!((typeof child   === \"object\") &&\n                  (typeof child.T === \"string\") &&\n                  (typeof child.L === \"object\") &&\n                  (typeof child.A === \"object\") &&\n                  (typeof child.P === \"object\") &&\n                  (typeof child.C === \"object\" && child.C instanceof Array)))\n                throw new Error(`add: invalid AST node: ${ JSON.stringify(child) }`)\n            node.C.push(child)\n            child.P = node\n        }\n        if (arguments !== null) {\n            Array.prototype.slice.call(arguments, 0).forEach((arg) => {\n                if (typeof arg === \"object\" && arg instanceof Array)\n                    arg.forEach((child) => { _add(this, child) })\n                else if (arg !== null)\n                    _add(this, arg)\n            })\n        }\n        return this\n    }\n\n    /*  delete child AST node(s)  */\n    del () {\n        if (arguments.length === 0)\n            throw new Error(\"del: invalid argument\")\n        Array.prototype.slice.call(arguments, 0).forEach((arg) => {\n            let found = false\n            for (let j = 0; j < this.C.length; j++) {\n                if (this.C[j] === arg) {\n                    this.C.splice(j, 1)\n                    arg.P = null\n                    found = true\n                    break\n                }\n            }\n            if (!found)\n                throw new Error(\"del: child not found\")\n        })\n        return this\n    }\n\n    /*  get child AST nodes  */\n    childs () {\n        return this.C\n    }\n\n    /*  get parent AST node  */\n    parent () {\n        return this.P\n    }\n}\n\n","/*\n**  ASTy -- Abstract Syntax Tree (AST) Data Structure\n**  Copyright (c) 2014-2015 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/* global 1: false */\n/* global 0: false */\n/* global 8: false */\n/* global 20150301:  false */\n\nlet version = {\n    major: 1,\n    minor: 0,\n    micro: 8,\n    date:  20150301\n}\n\nexport default version\n\n","/*\n**  ASTy -- Abstract Syntax Tree (AST) Data Structure\n**  Copyright (c) 2014-2015 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nexport default class ASTYMerge {\n    /*  merge attributes and childs of an AST node  */\n    merge (node, takePos, attrMap) {\n        if (typeof node !== \"object\")\n            throw new Error(\"merge: invalid AST node argument\")\n        if (typeof takePos === \"undefined\")\n            takePos = false\n        if (typeof attrMap === \"undefined\")\n            attrMap = {}\n        if (takePos) {\n            let pos = node.pos()\n            this.pos(pos.L, pos.C, pos.O)\n        }\n        node.attrs().forEach((attrSource) => {\n            let attrTarget = (\n                  typeof attrMap[attrSource] !== \"undefined\"\n                ? attrMap[attrSource]\n                : attrSource\n            )\n            if (attrTarget !== null)\n                this.set(attrTarget, node.get(attrSource))\n        })\n        node.childs().forEach((child) => {\n            this.add(child)\n        })\n        return this\n    }\n}\n\n"]}